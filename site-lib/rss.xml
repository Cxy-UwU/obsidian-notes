<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Notes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Notes</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 15 Jan 2026 13:13:12 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 15 Jan 2026 13:13:11 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Codeforces Round 1072 (Div. 3)]]></title><description><![CDATA[每个 team 有 2或3个 人，那么由若干个 team 组成的 civilization 可以有多少人？大于等于2的整数都是合法的。因此把输入的 个人分为两个 civilization ，只要输入大于等于4，能平分就平分，不能平分就差一。只有 的情况是特别考虑的。void solve(){ int n; cin &gt;&gt; n; if (n == 2) cout &lt;&lt; "2\n"; if (n == 3) cout &lt;&lt; "3\n"; if (n &gt;= 4) cout &lt;&lt; n % 2 &lt;&lt; '\n';
}
此题题面简单，没啥难的算法，但是debug有点烦，花了一些时间。从赛后投票来看，不喜欢这道题的人数是最多的(≧ω≦)。<img alt="Codeforces Round 1072 (Div. 3)-2026-01-13-dislike-problem-B.png" src="imgs/codeforces-round-1072-(div.-3)-2026-01-13-dislike-problem-b.png" target="_self" style="width: 350px; max-width: 100%;">本题的输入变量： 沙漏本身全部漏完所需的时间, 手动翻转沙漏的时间间隔, 操作者离开的时间点
首先，翻转沙漏就是一个有点讨厌的事情。一个比较方便的处理是，只看固定一端的沙子。例如，把最初沙子开始下落时，沙漏下方的那一端涂成红色，之后不管怎样翻转，就跟踪红色端的状态。考虑沙漏的这一端内部，以时间为单位的“沙量”，随“时间”的变化。它要么是斜率为1/-1的斜线（沙子正在漏），要么是水平线（沙子漏光了）。我们只需要找到 时刻操作者离开时，沙漏的状态，就能解这道题。<br><img alt="Codeforces Round 1072 (Div. 3)-2026-01-15-B.png" src="imgs/codeforces-round-1072-(div.-3)-2026-01-15-b.png" target="_self" style="width: 1000px; max-width: 100%;">尝试画一下上面的曲线。它们都是周期为 的曲线（每两次翻转，过程完全相同）。 时，其实并没有水平线，曲线是三角波，和 的形状不太一样。因而 和 这两种不同形状的曲线需要分开考虑。而每一个 周期内的前半和后半也是不同的状态（沙漏正向/反向），这也要分开考虑。用现在思路比较明确了，可以写出如下的代码：void solve() { int s, k, m; cin &gt;&gt; s &gt;&gt; k &gt;&gt; m; int i = m % (2 * k); if (s &gt;= k) { if (i &gt;= k) cout &lt;&lt; 2 * k - i &lt;&lt; endl; else cout &lt;&lt; s - i &lt;&lt; endl; } else { if (i &gt;= k) cout &lt;&lt; max(s + k - i, 0) &lt;&lt; endl; else cout &lt;&lt; max(s - i, 0) &lt;&lt; endl; }
}
赛时提交的代码 和 官方题解
赛时因为各种debug的缘故，基于一份原来的版本改来改去，把代码写成了下面这样。其实是对的，但是不容易读懂(=´ω `=)，反正我自己不太想读了。
int i = m % (2 * k);
if (i == k) cout &lt;&lt; min(s, k) &lt;&lt; endl;
else if (i == 0) cout &lt;&lt; s &lt;&lt; endl;
else if (i &gt; k) cout &lt;&lt; max(0, min(k, s) - i % k) &lt;&lt; endl;
else cout &lt;&lt; max(0, s - i) &lt;&lt; endl; 官方题解如下：
if (s &lt;= k) cout &lt;&lt; max(0, s - m % k) &lt;&lt; '\n';
else cout &lt;&lt; (((m % (2 * k)) &lt; k) ? s - m % k : k - m % k) &lt;&lt; '\n'; 这道题看起来像搜索，又是找“最近的”，就能想到BFS。写个暴力搜索，加个 unorderd_set 来给每一层将要搜的节点去重，提交，过了。void solve() { int total, target; cin &gt;&gt; total &gt;&gt; target; unordered_set&lt;int&gt; current_layer{total}; int depth = 0; while (!current_layer.empty()) { unordered_set&lt;int&gt; next_layer; if (current_layer.contains(target)) { // found! cout &lt;&lt; depth &lt;&lt; endl; return; } for (int num : current_layer) { int floor = num / 2, ceil = (num + 1) / 2; if (floor &gt;= target) next_layer.insert(floor); // 插入有希望继续搜素的值 if (ceil &gt;= target) next_layer.insert(ceil); } current_layer = std::move(next_layer); ++depth; } cout &lt;&lt; -1 &lt;&lt; endl;
}
过了当然就不想复杂度的事情了，肯定没问题的。但是……哦不对不对：赛后一想……对吗？看看我的内层 for 循环，是不是说，最坏的情况，每一个 current_layer 的 num 会给 next_layer 诞生两个孩子？最开始一个数，第一层搜两个数，第二层搜四个数，其实复杂度是 的？那不是炸了嘛。哦对的对的：其实没事的，我去开了个文档写写画画，发现可以用归纳法来证明，每一层的最小值和最大值至多差1，也就是说我大费周章搞的这个 unordered_set，里面元素最多的时候其实也只有两个(,,・ω・,,)，我们的算法最坏情况下复杂度也是 的，难怪能过这道题，没有被神秘样例拦下来呢。不过这也说明这道题是不需要 unordered_set 的，完全可以更简洁，两个 int 就够了。赛后复盘的意义就在这里吧，重新回看就能发现，有时通过了题目但其实没理解题目本质。题目描述
Bob：想好 之间的一个数， 为 的次幂。Alice知晓该数的奇偶性。
Alice可选的操作：减半（仅偶数）或 减去。
Bob的反馈： ，表示数字变为，此时爱丽丝获胜
非负整数𝑥，当前数值能够被 整除，不能被 整除 Bob希望，Alice无法在 步之内获胜。给定 ，，求 之间能符合这个要求的初始值的个数。
若是偶数，Alice 必然选减半。对于任意的一个数，Alice 需要几步来获胜呢？从二进制来考虑比较容易：若末位为0，去掉末位；若末位为1，将其改零。这个二进制数越来越短，最终变成0。去掉末位0需要一步，去掉末位1需要2步（除非只剩最后一个单独的1，只需一步）。有：. 输入是 是2的次幂，其二进制是1000...00，我们要看小于等于它的数里面，有多少的步数是大于k步的。对于给定的len，1的数量至多为len，至少为 。对于给定的 cnt_1，能够组合出来的不同的值有 个（最高位1固定）。写代码：int C_n_k(int n, int k) { if (k &gt; n) return 0; k = min(k, n - k); int res = 1; for (int i = 1; i &lt;= k; ++i) { res = res * (n - k + i) / i; } return res;
} void solve() { int n, k; cin &gt;&gt; n &gt;&gt; k; int len = 1, ans = 0; while (n &gt;&gt;= 1) len++; // 找到最高位的位置 if (len &gt; k) ++ans; // 实际上是 if (len+cnt1-1&gt;0) --len; for (; len &gt; 0; --len) for (int cnt1 = len; len + cnt1 - 1 &gt; k &amp;&amp; cnt1 &gt; 0; --cnt1) ans += C_n_k(len - 1, cnt1 - 1); cout &lt;&lt; ans &lt;&lt; endl;
}
吐槽一下，题面里面Bob给Alice的反馈，好像对我们解题没啥用啊……还没做。]]></description><link>算法题/codeforces/codeforces-round-1072-(div.-3).html</link><guid isPermaLink="false">算法题/Codeforces/Codeforces Round 1072 (Div. 3).md</guid><pubDate>Thu, 15 Jan 2026 13:13:03 GMT</pubDate><enclosure url="export/imgs/codeforces-round-1072-(div.-3)-2026-01-13-dislike-problem-b.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="export/imgs/codeforces-round-1072-(div.-3)-2026-01-13-dislike-problem-b.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CF R 1072 B]]></title><description><![CDATA[kkssks &gt;= k:s &lt; k:]]></description><link>excalidraw/cf-r-1072-b.html</link><guid isPermaLink="false">Excalidraw/CF R 1072 B.md</guid><pubDate>Tue, 13 Jan 2026 16:05:01 GMT</pubDate></item><item><title><![CDATA[CF R 1072 D]]></title><link>excalidraw/cf-r-1072-d.html</link><guid isPermaLink="false">Excalidraw/CF R 1072 D.md</guid><pubDate>Wed, 14 Jan 2026 17:15:20 GMT</pubDate></item><item><title><![CDATA[1. 数组、数组指针、指针数组]]></title><description><![CDATA[C++ 中，应当使用 std::vector 或 std::array 来代替 C 风格数组。这份笔记只是为了在学习过程中搞清楚一些概念而写的。形如 T a[N]; 的声明，将 a 声明为一个数组对象，该对象由N个连续分配的T类型对象组成。没有“引用数组”或者“函数数组”这种东西。void array_of_funcs[2](); // error: array of functions is not allowed
int &amp;array_of_refs[3]; // error: array of reference is not allowed void (*array_of_funcs[2])(); // 正确：数组元素是函数指针
array_of_funcs[0](); // 调用第一个函数
int *array_of_refs[3]; // 正确：数组存储指针
为什么 C++ 不允许“引用数组”，“函数数组”？
我的理解：因为引用不占据存储空间，没有自己的地址，实质上只是被引用对象的别名；函数没有固定大小，每个函数都有自己的内存布局。
数组要求同类型元素连续存储，每个元素有确定地址。让引用具有自己的地址、可被索引；让函数可以按固定大小连续排布在内存里，都是不合理的。
数组的元素类型可以是另一个已知边界的数组，此时称为多维数组。int mat1[2][3] = {1, 2, 3, 4, 5, 6}; // 合法 含2个元素的数组，每个元素是一个含3个int的数组。
int mat2[][3] = {1, 2, 3, 4, 5, 6}; // 合法 数组的元素是已知边界的数组int[3]，可由初始化推导行数
int mat3[3][] = {1, 2, 3, 4, 5, 6}; // 不合法！ 数组的元素是未知边界的数组
元素访问使用 []，称为 成员访问运算符 或 下标运算符。内置下标表达式 E1[E2] 与表达式 *(E1+E2) 完全相同，除了它的值类别 和 求值顺序(C++17 起) <a data-footref="1" href="#fn-1-3225058c471c687e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a>。至于 *(E1+E2) 里面，E1这个数组名为什么能够参与运算，会在下文提及。既然 E1[E2] 与 *(E1+E2) 相同，那么……
不考虑求值顺序，他们还和 *(E2+E1)，以及 [E2][E1] 相同。
岂不是 arr_name[idx] 的访问方式，也可以通过 idx[arr_name] 来访问？
做个无聊的小实验吧。C++标准应当能够保证，下面的代码是完全合法的：
int mat[2][3] = {1, 2, 3, 4, 5, 6};
// 以下六行代码都是取mat的[1][2]元素。
int i = mat[1][2];
int i = (*(mat + 1))[2]; // 若不加外层的小括号，[]的优先级比*高，导致计算顺序不同。
int i = *(mat[1]+2);
int i = *(*(mat+1)+2);
int i = 1[mat][2]; // 不要真的这么写，可读性很差，这里只是验证一下 E1[E2] 和 *(E1+E2) 的等价性而已！
int i = 2[1[mat]]; // 好吧，居然真的能运行…… <br>C语言中，ISO标准 和 编译器 对于 变长数组（Variable Length Array, VLA）有不同的规定和支持情况<a data-footref="2" href="#fn-2-3225058c471c687e" class="footnote-link" target="_self" rel="noopener nofollow">[2]</a>。但是 C++ 里从来都没有这个东西！这里还是以C++数组的情况为准，后面不再讨论变长数组相关的事情。毕竟C++有STL容器来提供类似的功能。C++数组的大小是“类型的一部分”。int a3[3] 和 int a5[5] 是不同的数据类型。前者可以叫做“array of 3 int”，后者可以叫做“array of 5 int”。#include &lt;type_traits&gt; // C++17
int a3[3] = {1, 2, 3};
int a5[5] = {1, 2, 3, 4, 5};
std::cout &lt;&lt; std::is_same_v&lt;decltype(a3), decltype(a5)&gt; &lt;&lt; std::endl;
// 输出 0
数组大小必须是大于0的常量表达式（可在编译期求值）；在编译时，编译器“知道”数组有多大。下例中，sizeof(a3) 在编译期就会直接处理为 12UL，该值直接硬编码进编译的结果里。std::cout &lt;&lt; "sizeof(a3) = " &lt;&lt; sizeof(a3) &lt;&lt; "\n"; // 输出 12
size_t len = sizeof(a3) / sizeof(a3[0]); // 3
<br>然而 没有 办法能够在运行时获取一个数组的大小，这是因为数组退化（隐式转换）成为指向首元素的指针导致的。下面的小标题 <a data-tooltip-position="top" aria-label="^2e513e" data-href="#^2e513e" href="#^2e513e" class="internal-link" target="_self" rel="noopener nofollow">数组会退化为首元素指针</a> 就是谈这个问题。一些教程说“数组名就是指向首元素的指针”（大一的时候，工科的C/C++通识课就是这样说的），然而这个表述并不正确。最直观的区别是，数组和指向首元素的指针的sizeof()结果不相同。int arr[5];
auto size_of_arr = sizeof(arr); // 20 UL 数组的大小
auto size_of_ptr = sizeof(&amp;arr[0]); // 8 UL 指针的大小
auto size_of_element = sizeof(arr[0]); // 4 UL int的大小
更进一步地，可以用C++17的 type_traits 写如下程序，说明数组是数组，指针是指针，它们并不是一个东西。int arr[5];
std::cout &lt;&lt; "is_pointer:" &lt;&lt; std::is_pointer_v&lt;decltype(arr)&gt; &lt;&lt; std::endl; // 0
std::cout &lt;&lt; "is_array:" &lt;&lt; std::is_array_v&lt;decltype(arr)&gt; &lt;&lt; std::endl; // 1 auto ptr = arr; // 等价于 auto ptr = &amp;arr[0]; 或者 auto ptr = arr + 0;
std::cout &lt;&lt; "is_pointer:" &lt;&lt; std::is_pointer_v&lt;decltype(ptr)&gt; &lt;&lt; std::endl; // 1
std::cout &lt;&lt; "is_array:" &lt;&lt; std::is_array_v&lt;decltype(ptr)&gt; &lt;&lt; std::endl; // 0
数组在大多数表达式中会隐式转换为指向其首元素的指针，这叫做"数组到指针的衰变"（array-to-pointer decay）或者退化。上面 auto ptr = arr; 是一个例子，arr 的类型是 int[5]，推导的 auto ptr 类型是 int *，此时对于 ptr 而言，数组的大小信息就丢失了，只有首元素的地址，而不知道这个数组是在什么地方截止的。另一个典型的例子是将数组作为函数的形参传递：void f(int a[]){}
void f(int a[5]){}
void f(int *a){}
这三个函数实际上都是 void f(int *a){}，一起编译时，会直接报 error: redefinition of 'void f(int*)'。它们之间也不存在什么重载关系，纯粹是相同的函数被重复定义。对于函数：size_t f(int a[]){ return sizeof(a);
}
由于实际传入的是 int *a，该函数不管传入什么东西，始终返回指针的大小 8。我的编译器会对此给出警告。由于函数内不能够知道数组的长度，所以C的写法常常还会额外传入一个整型，表示要处理的数组元素个数。对于多维数组，数组到指针的退化只应用一次（最外层）：int a[2]; // array of 2 int
int* p1 = a; // a decays to a pointer to the first element of a int b[2][3]; // array of 2 arrays of 3 int
// int** p2 = b; // error: b does not decay to int**
int (*p2)[3] = b; // b decays to a pointer to the first 3-element row of b int c[2][3][4]; // array of 2 arrays of 3 arrays of 4 int
// int*** p3 = c; // error: c does not decay to int***
int (*p3)[3][4] = c; // c decays to a pointer to the first 3 × 4-element plane of c
<br><a data-tooltip-position="top" aria-label="^2e513e" data-href="#^2e513e" href="#^2e513e" class="internal-link" target="_self" rel="noopener nofollow">1.3.2</a> 谈到了数组会退化为指向首元素的指针，从而丢失了它的大小信息。有另一种指针 “指向数组的指针” ，容易和上文 “指向数组首元素的指针”相混淆，然而实际上它们也是不同的东西。指向数组的指针保留了数组的大小信息。int (*p_arr)[5]; // 指向数组的指针，这个被指向的数组类型为int[5]
<br>注意这个括号是一定要带的，不然它又是另一种东西了……我们会在 <a data-tooltip-position="top" aria-label="^74e69e" data-href="#^74e69e" href="#^74e69e" class="internal-link" target="_self" rel="noopener nofollow">1.5</a> 中再见到它。int arr[5] = {1, 2, 3, 4, 5};
int (*p_arr)[5] = &amp;arr; // 数组指针
int *p_elem = arr; // 首元素指针 std::cout &lt;&lt; "数组地址测试:" &lt;&lt; std::endl;
std::cout &lt;&lt; "arr: " &lt;&lt; (void*)arr &lt;&lt; std::endl;
std::cout &lt;&lt; "&amp;arr[0]: " &lt;&lt; (void*)&amp;arr[0] &lt;&lt; std::endl;
std::cout &lt;&lt; "&amp;arr: " &lt;&lt; (void*)p_arr &lt;&lt; std::endl;
std::cout &lt;&lt; "p_elem: " &lt;&lt; (void*)p_elem &lt;&lt; std::endl;
std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "指针运算测试:" &lt;&lt; std::endl;
std::cout &lt;&lt; "p_elem: " &lt;&lt; (void*)p_elem &lt;&lt; std::endl;
std::cout &lt;&lt; "p_elem+1: " &lt;&lt; (void*)(p_elem + 1) &lt;&lt; std::endl;
std::cout &lt;&lt; "差值: " &lt;&lt; ((char*)(p_elem + 1) - (char*)p_elem) &lt;&lt; " 字节" &lt;&lt; std::endl; std::cout &lt;&lt; std::endl;
std::cout &lt;&lt; "p_arr: " &lt;&lt; (void*)p_arr &lt;&lt; std::endl;
std::cout &lt;&lt; "p_arr+1: " &lt;&lt; (void*)(p_arr + 1) &lt;&lt; std::endl;
std::cout &lt;&lt; "差值: " &lt;&lt; ((char*)(p_arr + 1) - (char*)p_arr) &lt;&lt; " 字节" &lt;&lt; std::endl;
std::cout &lt;&lt; std::endl; std::cout &lt;&lt; "数组访问:" &lt;&lt; std::endl;
std::cout &lt;&lt; "通过p_elem访问: p_elem[2] = " &lt;&lt; p_elem[2] &lt;&lt; std::endl;
std::cout &lt;&lt; "通过p_arr访问: (*p_arr)[2] = " &lt;&lt; (*p_arr)[2] &lt;&lt; std::endl;
std::cout &lt;&lt; "原始数组访问: arr[2] = " &lt;&lt; arr[2] &lt;&lt; std::endl;
std::cout &lt;&lt; std::endl;
可能的输出：数组地址测试:
arr: 0x16b646968
&amp;arr[0]: 0x16b646968
&amp;arr: 0x16b646968
p_elem: 0x16b646968 指针运算测试:
p_elem: 0x16b646968
p_elem+1: 0x16b64696c
差值: 4 字节 p_arr: 0x16b646968
p_arr+1: 0x16b64697c
差值: 20 字节 数组访问:
通过p_elem访问: p_elem[2] = 3
通过p_arr访问: (*p_arr)[2] = 3
原始数组访问: arr[2] = 3
<br><img alt="1. 数组数组指针指针数组-2026-01-12.png" src="imgs/1.-数组数组指针指针数组-2026-01-12.png" target="_self" style="width: 600px; max-width: 100%;">既然 int (*p_arr)[5] 是指向数组的指针，它是个指针，当然也可以当做函数的参数来传递。void print_array_size(int (*p_arr)[5]) // 参数是指向int[5]的指针
{ // 解引用得到数组 int (&amp;arr)[5] = *p_arr; // 或直接使用 *p_arr std::cout &lt;&lt; "sizeof(*p_arr) = " &lt;&lt; sizeof(*p_arr) &lt;&lt; std::endl; // 20 std::cout &lt;&lt; "Array size = " &lt;&lt; sizeof(*p_arr) / sizeof((*p_arr)[0]) &lt;&lt; std::endl; // 5
}
这时候，Array size 的信息蕴含在数组指针的类型中。既然 int (*p_arr)[5] = &amp;arr; 是指向数组的指针，去掉类型中的小括号，它是什么呢？int *p[5] = {&amp;a1,&amp;a2,&amp;a3,&amp;a4,&amp;a5}; C++中，中括号的运算符优先级要高于星号，上面的类型实际上等价于：int *(p[5]);
这是一个大小为5的数组，数组的元素类型为 int *.<br>如果把 <a data-tooltip-position="top" aria-label="^0f7038" data-href="#^0f7038" href="#^0f7038" class="internal-link" target="_self" rel="noopener nofollow">1.4</a> 称为“数组指针”，那么这个东西可以叫做“指针数组”。呼，感觉已经很晕很晕了！但是关于数组和/或指针的情况，好像还有挺多细节没有覆盖到……例如：C++标准允许未知边界的数组，同时也允许指向它的指针，例如，extern int ARR_global[]; // 可以不指明外部数组的大小。 void print_first_elem(int (*p_arr)[]) // 数组指针，中括号里不填大小也OK
{ int (&amp;arr)[] = *p_arr; std::cout &lt;&lt; arr[0] &lt;&lt; std::endl;
}
这些东西是怎么处理的？我暂时没有深入这个话题。int (&amp;arr)[5] 这种东西，变量名 arr 的左右都有类型信息，可读性很差。可以使用类型别名（ C++ using）优化数组类型的可读性：using Array5 = int[5];
Array5 arr= {1,2,3,4,5};
Array5 *p_arr = &amp;arr;
<br>更复杂的C指针读法遵循一套螺旋法则 见 <a data-tooltip-position="top" aria-label="https://www.geeksforgeeks.org/cpp/clockwise-spiral-rule-in-c-c-with-examples/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.geeksforgeeks.org/cpp/clockwise-spiral-rule-in-c-c-with-examples/" target="_self">Clockwise/Spiral Rule in C/C++ with Examples - GeeksforGeeks</a>。后面学完函数指针之后，我可以把这个东西也串着记到笔记里。<br>小总结，来自<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1nViRYJE4R" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.bilibili.com/video/BV1nViRYJE4R" target="_self">指针、数组，傻傻分不清楚？_哔哩哔哩_bilibili</a>：<br><img alt="5A145661-3DAE-4D0B-ACE4-2A0B98C2A12A_1_201_a 2.jpeg" src="imgs/5a145661-3dae-4d0b-ace4-2a0b98c2a12a_1_201_a-2.jpeg" target="_self"><br><a data-tooltip-position="top" aria-label="https://cppreference.cn/w/cpp/language/array" rel="noopener nofollow" class="external-link is-unresolved" href="https://cppreference.cn/w/cpp/language/array" target="_self">数组声明 - cppreference.cn - C++参考手册</a><br><a data-tooltip-position="top" aria-label="https://cppreference.cn/w/cpp/language/operator_member_access#Built-in_subscript_operator" rel="noopener nofollow" class="external-link is-unresolved" href="https://cppreference.cn/w/cpp/language/operator_member_access#Built-in_subscript_operator" target="_self">成员访问运算符 - cppreference.cn - C++参考手册</a><br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1nViRYJE4R" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.bilibili.com/video/BV1nViRYJE4R" target="_self">指针、数组，傻傻分不清楚？_哔哩哔哩_bilibili</a> <br>先不管 值类别 和 求值顺序 了。暂时聚焦于主题，否则递归学习恐怕是无止尽的 qwq。<a href="#fnref-1-3225058c471c687e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
<br>变长数组最早在 C99 标准引入，在栈上分配；但是微软反对该特性，故MSVC不支持。
可能是因为微软的反对，C11 标准将其变成可选特性，编译器可以选择不支持它；
C23 起，变长数组又变成强制特性。然而，MSVC截至今天还是不支持VLA。<a href="#fnref-2-3225058c471c687e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>编程/c++/c++-补遗/1.-数组、数组指针、指针数组.html</link><guid isPermaLink="false">编程/C++/C++ 补遗/1. 数组、数组指针、指针数组.md</guid><pubDate>Thu, 15 Jan 2026 13:05:56 GMT</pubDate><enclosure url="export/imgs/1.-数组数组指针指针数组-2026-01-12.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="export/imgs/1.-数组数组指针指针数组-2026-01-12.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[About]]></title><description><![CDATA[这是我的 <a data-tooltip-position="top" aria-label="https://obsidian.md/" rel="noopener nofollow" class="external-link is-unresolved" href="https://obsidian.md/" target="_self">Obsidian</a> Vault 的一个子集。Obsidian 用户多才多艺。有人说要借助它构建第二大脑，有人说要建立数字花园或者博客站。笔者很懒，没有这些远大的想法，一直只是把 Obsidian 当做一个写 Markdown 的地方，偶尔写点笔记。最近发现了能够导出笔记成为静态页面的方法，于是想试验性地导出一些东西，部署到 Pages 试试看。嗯……这个页面就是这样来的。现在这里很简陋，未来或许也会继续简陋下去，但是也说不定哪天会突然想起来，又往这里添点东西，总之一切随缘吧～忙前忙后，乱七八糟的2025年已经结束了。新年要立 Flag，我的Flag之一是：今年要系统性地刷些算法题。之前对自己的未来感到迷茫、焦虑的时候，我就去牛客上面刷找工作的经验贴；刷完之后更焦虑了。我发现，先不管有什么项目经验，也不必说会什么技术，做什么方向，有很硬性的一关总是要面对的，那就是：手撕代码！然而我在这方面确实是水平不行。诚然算法设计课程也上了，考试也考了，但是不练终归是不行的，所以今年的Flag是刷算法题，目前准备从 Leetcode Hot 100 开始刷起。Leetcode 记录：<br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC1 两数之和.md" data-href="算法题/Leetcode/LC1 两数之和.md" href="算法题/leetcode/lc1-两数之和.html" class="internal-link" target="_self" rel="noopener nofollow">LC1 两数之和</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC2 两数相加.md" data-href="算法题/Leetcode/LC2 两数相加.md" href="算法题/leetcode/lc2-两数相加.html" class="internal-link" target="_self" rel="noopener nofollow">LC2 两数相加</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC283 移动零.md" data-href="算法题/Leetcode/LC283 移动零.md" href="算法题/leetcode/lc283-移动零.html" class="internal-link" target="_self" rel="noopener nofollow">LC283 移动零</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC49 字母异位词分组.md" data-href="算法题/Leetcode/LC49 字母异位词分组.md" href="算法题/leetcode/lc49-字母异位词分组.html" class="internal-link" target="_self" rel="noopener nofollow">LC49 字母异位词分组</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC50 Pow(x,n).md" data-href="算法题/Leetcode/LC50 Pow(x,n).md" href="算法题/leetcode/lc50-pow(x,n).html" class="internal-link" target="_self" rel="noopener nofollow">LC50 Pow(x,n)</a>]]></description><link>about.html</link><guid isPermaLink="false">About.md</guid><pubDate>Sun, 11 Jan 2026 15:50:59 GMT</pubDate></item><item><title><![CDATA[LC50 Pow(x,n)]]></title><description><![CDATA[以计算 为例。最简单的想法是累乘 次，依次得到得到 , , , ,..., . 这个算法的时间复杂度是 ，因为每次累乘让指数增长 ，直至达到目标的指数 。不过有了 , 可以直接倍增，算出 . 考虑通过不断倍增，我们能够非常快地得到 ；最终我们想要的 可以由 组合出来。
把 的二进制从低位到高位逐步处理，处理每一位时，都让 倍增。当二进制为 时，意味着我们需要这个 ，将其乘进 ；否则仅仅是倍增 。二进制位数是 ，所以只需要做 次乘法。快速幂模板：double myPow(double x, int n) { long long _n=n; if(n&lt;0){x=1/x; _n=-_n;} double ans=1; while(_n){ if(_n&amp;1) ans*=x; x*=x; _n&gt;&gt;=1; } return ans;
}
本题还需考虑负次幂，尤其是为了-2147483648这个样例，去给 n 开个 long long 😅。]]></description><link>算法题/leetcode/lc50-pow(x,n).html</link><guid isPermaLink="false">算法题/Leetcode/LC50 Pow(x,n).md</guid><pubDate>Sun, 11 Jan 2026 15:45:15 GMT</pubDate></item><item><title><![CDATA[LC1 两数之和]]></title><description><![CDATA[对于一个数 a，我们想找到有没有另一数 b = target - a 是否也在数组中，并找到其下标。存储当前值和其下标，到一 unordered_map 中。每来一个数都回到这个 unordered_map 里面查找。std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt; &amp;nums, int target)
{ std::unordered_map&lt;int, int&gt; m; for (auto [i, e] : std::views::enumerate(nums)) { if (m.contains(target - e)) return {m.at(target - e), static_cast&lt;int&gt;(i)}; m[e] = static_cast&lt;int&gt;(i); } return {};
}
]]></description><link>算法题/leetcode/lc1-两数之和.html</link><guid isPermaLink="false">算法题/Leetcode/LC1 两数之和.md</guid><pubDate>Thu, 08 Jan 2026 04:06:39 GMT</pubDate></item><item><title><![CDATA[LC2 两数相加]]></title><description><![CDATA[在单链表上，模拟竖式加法。算法很简单，但是对于 ListNode* 的操作容易写错。ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode head; // 这里不能new！函数外部是访问不到这个头节点的，head只能在栈上。 auto p = &amp;head; int carry = 0; // 记录进位 for (; l1 || l2 || carry; l1 = l1 ? l1-&gt;next : l1, l2 = l2 ? l2-&gt;next : l2) { auto sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry; p = p-&gt;next = new ListNode(sum % 10); carry = sum / 10; } return head.next;
}
]]></description><link>算法题/leetcode/lc2-两数相加.html</link><guid isPermaLink="false">算法题/Leetcode/LC2 两数相加.md</guid><pubDate>Thu, 08 Jan 2026 04:04:40 GMT</pubDate></item><item><title><![CDATA[LC283 移动零]]></title><description><![CDATA[C++学得越多，对C++了解越少。去翻了一下标准库，发现 C++20 引入了 stable_partition，作用是“把满足谓词条件的所有元素挪到最前面，保持元素相对顺序”。我们要把0全挪到最后，等于把非零全挪到最前，于是该题有一行就能写出来的解法：void moveZeroes(std::vector&lt;int&gt;&amp; nums) { std::ranges::stable_partition(nums, [](int x) { return x != 0; });
}
stable_partition 有额外内存缓冲区时可以做到 ；若无额外内存缓冲区，最坏会是 次交换（分治+旋转）。stable_partition 是怎么实现的？
有额外内存缓冲区时： 把满足谓词的先按顺序输出到缓冲区1 不满足的按顺序输出到缓冲区2 最后把缓冲区内容移回原区间 每个元素操作常数次，故为 。 无额外内存缓冲区时：
做法（递归）： 如果区间长度 ≤ 1，直接返回 把区间 一分为二 递归地对左半、右半分别做 stable_partition 此时区间形态是：
左：[T...][F...] 右：[T...][F...] 用一次 rotate，把中间两段拼成：
[左T...][右T...][左F...][右F...] 然而调用标准库并不是本题的最优解！因为标准库的 stable_partition 并不事先知道，我们要挪到后面的值全都是相等的 0，stable_partition事实上对这些一样的 0 也保留了次序。同样完成这道题目，stable_partition 实际上额外做了不必要的事（或者说是少用了题目条件）。可以一次线性扫描 + 原地覆盖 解决。void moveZeroes(std::vector&lt;int&gt;&amp; nums) { int i = 0; for (auto e : nums) if (e != 0) nums[i++] = e; while (i &lt; nums.size()) nums[i++] = 0;
}
]]></description><link>算法题/leetcode/lc283-移动零.html</link><guid isPermaLink="false">算法题/Leetcode/LC283 移动零.md</guid><pubDate>Thu, 08 Jan 2026 04:03:52 GMT</pubDate></item><item><title><![CDATA[LC49 字母异位词分组]]></title><description><![CDATA[
Sorted string as key; original string append to val.std::vector&lt;std::vector&lt;std::string&gt;&gt; groupAnagrams(std::vector&lt;std::string&gt; &amp;strs)
{ std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; m; for (auto s : strs) { std::string k = s; std::ranges::sort(k); m[k].emplace_back(s); } std::vector&lt;std::vector&lt;std::string&gt;&gt; ans; for (const auto &amp;[_, val] : m) ans.emplace_back(val); return ans;
}
]]></description><link>算法题/leetcode/lc49-字母异位词分组.html</link><guid isPermaLink="false">算法题/Leetcode/LC49 字母异位词分组.md</guid><pubDate>Thu, 08 Jan 2026 04:03:31 GMT</pubDate></item><item><title><![CDATA[关于]]></title><description><![CDATA[这是我的 <a data-tooltip-position="top" aria-label="https://obsidian.md/" rel="noopener nofollow" class="external-link is-unresolved" href="https://obsidian.md/" target="_self">Obsidian</a> Vault 的一个子集。Obsidian 用户多才多艺。有人说要借助它构建第二大脑，有人说要建立数字花园或者博客站。笔者很懒，没有这些远大的想法，一直只是把 Obsidian 当做一个写 Markdown 的地方，偶尔写点笔记。最近发现了能够导出笔记成为静态页面的方法，于是想试验性地导出一些东西，部署到 Pages 试试看。嗯……这个页面就是这样来的。现在这里很简陋，未来或许也会继续简陋下去，但是也说不定哪天会突然想起来，又往这里添点东西，总之一切随缘吧～忙前忙后，乱七八糟的2025年已经结束了。新年要立 Flag，我的Flag之一是：今年要系统性地刷些算法题。之前对自己的未来感到迷茫、焦虑的时候，我就去牛客上面刷找工作的经验贴；刷完之后更焦虑了。我发现，先不管有什么项目经验，也不必说会什么技术，做什么方向，有很硬性的一关总是要面对的，那就是：手撕代码！然而我在这方面确实是水平不行。诚然算法设计课程也上了，考试也考了，但是不练终归是不行的，所以今年的Flag是刷算法题，目前准备从 Leetcode Hot 100 开始刷起。Leetcode 记录：<br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC1 两数之和.md" data-href="算法题/Leetcode/LC1 两数之和.md" href="算法题/leetcode/lc1-两数之和.html" class="internal-link" target="_self" rel="noopener nofollow">LC1 两数之和</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC2 两数相加.md" data-href="算法题/Leetcode/LC2 两数相加.md" href="算法题/leetcode/lc2-两数相加.html" class="internal-link" target="_self" rel="noopener nofollow">LC2 两数相加</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC283 移动零.md" data-href="算法题/Leetcode/LC283 移动零.md" href="算法题/leetcode/lc283-移动零.html" class="internal-link" target="_self" rel="noopener nofollow">LC283 移动零</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC49 字母异位词分组.md" data-href="算法题/Leetcode/LC49 字母异位词分组.md" href="算法题/leetcode/lc49-字母异位词分组.html" class="internal-link" target="_self" rel="noopener nofollow">LC49 字母异位词分组</a><br><a data-tooltip-position="top" aria-label="算法题/Leetcode/LC50 Pow(x,n).md" data-href="算法题/Leetcode/LC50 Pow(x,n).md" href="算法题/leetcode/lc50-pow(x,n).html" class="internal-link" target="_self" rel="noopener nofollow">LC50 Pow(x,n)</a>]]></description><link>关于.html</link><guid isPermaLink="false">关于.md</guid><pubDate>Thu, 08 Jan 2026 04:11:10 GMT</pubDate></item><item><title><![CDATA[LC1]]></title><description><![CDATA[对于一个数 a，我们想找到有没有另一数 b = target - a 是否也在数组中，并找到其下标。存储当前值和其下标，到一 unordered_map 中。每来一个数都回到这个 unordered_map 里面查找。std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt; &amp;nums, int target)
{ std::unordered_map&lt;int, int&gt; m; for (auto [i, e] : std::views::enumerate(nums)) { if (m.contains(target - e)) return {m.at(target - e), static_cast&lt;int&gt;(i)}; m[e] = static_cast&lt;int&gt;(i); } return {};
}
]]></description><link>算法题/leetcode/lc1.html</link><guid isPermaLink="false">算法题/Leetcode/LC1.md</guid><pubDate>Sun, 04 Jan 2026 18:01:05 GMT</pubDate></item><item><title><![CDATA[关于...]]></title><description><![CDATA[这是我的 <a data-tooltip-position="top" aria-label="https://obsidian.md/" rel="noopener nofollow" class="external-link is-unresolved" href="https://obsidian.md/" target="_self">Obsidian</a> Vault 的一个子集。Obsidian 用户多才多艺。有人说要借助它构建第二大脑，有人说要建立数字花园或者博客站。笔者很懒，没有这些远大的想法，一直只是把 Obsidian 当做一个写 Markdown 的地方，偶尔写点笔记。最近发现了能够导出笔记成为静态页面的方法，于是想试验性地导出一些东西，部署到 Pages 试试看。嗯……这个页面就是这样来的。现在这里很简陋，未来或许也会继续简陋下去，但是也说不定哪天会突然想起来，又往这里添点东西，总之一切随缘吧～忙前忙后，乱七八糟的2025年已经结束了。新年要立 Flag，我的Flag之一是：今年要系统性地刷些算法题。之前对自己的未来感到迷茫、焦虑的时候，我就去牛客上面刷找工作的经验贴；刷完之后更焦虑了。我发现，先不管有什么项目经验，也不必说会什么技术，做什么方向，有很硬性的一关总是要面对的，那就是：手撕代码！然而我在这方面确实是水平不行。诚然算法设计课程也上了，考试也考了，但是不练终归是不行的，所以今年的Flag是刷算法题，目前准备从 Leetcode Hot 100 开始刷起。<br><a data-href="LC1" href="算法题/leetcode/lc1.html" class="internal-link" target="_self" rel="noopener nofollow">LC1</a><br><a data-href="LC49" href="算法题/leetcode/lc49.html" class="internal-link" target="_self" rel="noopener nofollow">LC49</a><br><a data-href="LC50" href="算法题/leetcode/lc50.html" class="internal-link" target="_self" rel="noopener nofollow">LC50</a><br><a data-href="LC283" href="算法题/leetcode/lc283.html" class="internal-link" target="_self" rel="noopener nofollow">LC283</a>]]></description><link>关于....html</link><guid isPermaLink="false">关于....md</guid><pubDate>Sun, 04 Jan 2026 17:45:39 GMT</pubDate></item><item><title><![CDATA[LC50]]></title><description><![CDATA[快速幂模板：double myPow(double x, int n) { long long _n=n; if(n&lt;0){x=1/x; _n=-_n;} double ans=1; while(_n){ if(_n&amp;1) ans*=x; x*=x; _n&gt;&gt;=1; } return ans;
}
]]></description><link>算法题/leetcode/lc50.html</link><guid isPermaLink="false">算法题/Leetcode/LC50.md</guid><pubDate>Sun, 04 Jan 2026 16:36:28 GMT</pubDate></item><item><title><![CDATA[LC283]]></title><description><![CDATA[C++学得越多，对C++了解越少。去翻了一下标准库，发现 C++20 引入了 stable_partition，作用是“把满足谓词条件的所有元素挪到最前面，保持元素相对顺序”。我们要把0全挪到最后，等于把非零全挪到最前，于是该题有一行就能写出来的解法：void moveZeroes(std::vector&lt;int&gt;&amp; nums) { std::ranges::stable_partition(nums, [](int x) { return x != 0; });
}
stable_partition 有额外内存缓冲区时可以做到 ；若无额外内存缓冲区，最坏会是 次交换（分治+旋转）。stable_partition 是怎么实现的？
有额外内存缓冲区时： 把满足谓词的先按顺序输出到缓冲区1 不满足的按顺序输出到缓冲区2 最后把缓冲区内容移回原区间 每个元素操作常数次，故为 。 无额外内存缓冲区时：
做法（递归）： 如果区间长度 ≤ 1，直接返回 把区间 一分为二 递归地对左半、右半分别做 stable_partition 此时区间形态是：
左：[T...][F...] 右：[T...][F...] 用一次 rotate，把中间两段拼成：
[左T...][右T...][左F...][右F...] 然而调用标准库并不是本题的最优解！因为标准库的 stable_partition 并不事先知道，我们要挪到后面的值全都是相等的 0，stable_partition事实上对这些一样的 0 也保留了次序。同样完成这道题目，stable_partition 实际上额外做了不必要的事（或者说是少用了题目条件）。可以一次线性扫描 + 原地覆盖 解决。void moveZeroes(std::vector&lt;int&gt;&amp; nums) { int i = 0; for (auto e : nums) if (e != 0) nums[i++] = e; while (i &lt; nums.size()) nums[i++] = 0;
}
]]></description><link>算法题/leetcode/lc283.html</link><guid isPermaLink="false">算法题/Leetcode/LC283.md</guid><pubDate>Sun, 04 Jan 2026 16:31:56 GMT</pubDate></item><item><title><![CDATA[LC49]]></title><description><![CDATA[
Sorted string as key; original string append to val.std::vector&lt;std::vector&lt;std::string&gt;&gt; groupAnagrams(std::vector&lt;std::string&gt; &amp;strs)
{ std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; m; for (auto s : strs) { std::string k = s; std::ranges::sort(k); m[k].emplace_back(s); } std::vector&lt;std::vector&lt;std::string&gt;&gt; ans; for (const auto &amp;[_, val] : m) ans.emplace_back(val); return ans;
}
]]></description><link>算法题/leetcode/lc49.html</link><guid isPermaLink="false">算法题/Leetcode/LC49.md</guid><pubDate>Sun, 04 Jan 2026 16:31:17 GMT</pubDate></item></channel></rss>