<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Notes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>Notes</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 04 Jan 2026 17:45:41 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 04 Jan 2026 17:45:41 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[关于...]]></title><description><![CDATA[这是我的 <a data-tooltip-position="top" aria-label="https://obsidian.md/" rel="noopener nofollow" class="external-link is-unresolved" href="https://obsidian.md/" target="_self">Obsidian</a> Vault 的一个子集。Obsidian 用户多才多艺。有人说要借助它构建第二大脑，有人说要建立数字花园或者博客站。笔者很懒，没有这些远大的想法，一直只是把 Obsidian 当做一个写 Markdown 的地方，偶尔写点笔记。最近发现了能够导出笔记成为静态页面的方法，于是想试验性地导出一些东西，部署到 Pages 试试看。嗯……这个页面就是这样来的。现在这里很简陋，未来或许也会继续简陋下去，但是也说不定哪天会突然想起来，又往这里添点东西，总之一切随缘吧～忙前忙后，乱七八糟的2025年已经结束了。新年要立 Flag，我的Flag之一是：今年要系统性地刷些算法题。之前对自己的未来感到迷茫、焦虑的时候，我就去牛客上面刷找工作的经验贴；刷完之后更焦虑了。我发现，先不管有什么项目经验，也不必说会什么技术，做什么方向，有很硬性的一关总是要面对的，那就是：手撕代码！然而我在这方面确实是水平不行。诚然算法设计课程也上了，考试也考了，但是不练终归是不行的，所以今年的Flag是刷算法题，目前准备从 Leetcode Hot 100 开始刷起。<br><a data-href="LC1" href="算法题/leetcode/lc1.html" class="internal-link" target="_self" rel="noopener nofollow">LC1</a><br><a data-href="LC49" href="算法题/leetcode/lc49.html" class="internal-link" target="_self" rel="noopener nofollow">LC49</a><br><a data-href="LC50" href="算法题/leetcode/lc50.html" class="internal-link" target="_self" rel="noopener nofollow">LC50</a><br><a data-href="LC283" href="算法题/leetcode/lc283.html" class="internal-link" target="_self" rel="noopener nofollow">LC283</a>]]></description><link>关于....html</link><guid isPermaLink="false">关于....md</guid><pubDate>Sun, 04 Jan 2026 17:45:39 GMT</pubDate></item><item><title><![CDATA[LC50]]></title><description><![CDATA[快速幂模板：double myPow(double x, int n) { long long _n=n; if(n&lt;0){x=1/x; _n=-_n;} double ans=1; while(_n){ if(_n&amp;1) ans*=x; x*=x; _n&gt;&gt;=1; } return ans;
}
]]></description><link>算法题/leetcode/lc50.html</link><guid isPermaLink="false">算法题/Leetcode/LC50.md</guid><pubDate>Sun, 04 Jan 2026 16:36:28 GMT</pubDate></item><item><title><![CDATA[LC283]]></title><description><![CDATA[C++学得越多，对C++了解越少。去翻了一下标准库，发现 C++20 引入了 stable_partition，作用是“把满足谓词条件的所有元素挪到最前面，保持元素相对顺序”。我们要把0全挪到最后，等于把非零全挪到最前，于是该题有一行就能写出来的解法：void moveZeroes(std::vector&lt;int&gt;&amp; nums) { std::ranges::stable_partition(nums, [](int x) { return x != 0; });
}
stable_partition 有额外内存缓冲区时可以做到 ；若无额外内存缓冲区，最坏会是 次交换（分治+旋转）。stable_partition 是怎么实现的？
有额外内存缓冲区时： 把满足谓词的先按顺序输出到缓冲区1 不满足的按顺序输出到缓冲区2 最后把缓冲区内容移回原区间 每个元素操作常数次，故为 。 无额外内存缓冲区时：
做法（递归）： 如果区间长度 ≤ 1，直接返回 把区间 一分为二 递归地对左半、右半分别做 stable_partition 此时区间形态是：
左：[T...][F...] 右：[T...][F...] 用一次 rotate，把中间两段拼成：
[左T...][右T...][左F...][右F...] 然而调用标准库并不是本题的最优解！因为标准库的 stable_partition 并不事先知道，我们要挪到后面的值全都是相等的 0，stable_partition事实上对这些一样的 0 也保留了次序。同样完成这道题目，stable_partition 实际上额外做了不必要的事（或者说是少用了题目条件）。可以一次线性扫描 + 原地覆盖 解决。void moveZeroes(std::vector&lt;int&gt;&amp; nums) { int i = 0; for (auto e : nums) if (e != 0) nums[i++] = e; while (i &lt; nums.size()) nums[i++] = 0;
}
]]></description><link>算法题/leetcode/lc283.html</link><guid isPermaLink="false">算法题/Leetcode/LC283.md</guid><pubDate>Sun, 04 Jan 2026 16:31:56 GMT</pubDate></item><item><title><![CDATA[LC49]]></title><description><![CDATA[
Sorted string as key; original string append to val.std::vector&lt;std::vector&lt;std::string&gt;&gt; groupAnagrams(std::vector&lt;std::string&gt; &amp;strs)
{ std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; m; for (auto s : strs) { std::string k = s; std::ranges::sort(k); m[k].emplace_back(s); } std::vector&lt;std::vector&lt;std::string&gt;&gt; ans; for (const auto &amp;[_, val] : m) ans.emplace_back(val); return ans;
}
]]></description><link>算法题/leetcode/lc49.html</link><guid isPermaLink="false">算法题/Leetcode/LC49.md</guid><pubDate>Sun, 04 Jan 2026 16:31:17 GMT</pubDate></item><item><title><![CDATA[LC1]]></title><description><![CDATA[
对于一个数 `a`，我们想找到有没有另一数 `b = target - a` 是否也在数组中，并找到其下标。存储当前值和其下标，到一 unordered_map 中。每来一个数都回到这个 unordered_map 里面查找。std::vector&lt;int&gt; twoSum(std::vector&lt;int&gt; &amp;nums, int target)
{ std::unordered_map&lt;int, int&gt; m; for (auto [i, e] : std::views::enumerate(nums)) { if (m.contains(target - e)) return {m.at(target - e), static_cast&lt;int&gt;(i)}; m[e] = static_cast&lt;int&gt;(i); } return {};
}
]]></description><link>算法题/leetcode/lc1.html</link><guid isPermaLink="false">算法题/Leetcode/LC1.md</guid><pubDate>Sun, 04 Jan 2026 16:30:20 GMT</pubDate></item></channel></rss>